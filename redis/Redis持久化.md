#RDB持久化
    
   + 简介
        
           Redis是内存数据库，一旦服务器进程退出，内存中保存的数据库状态就会丢失；RDB持久化便是将数据持久化到磁盘的一种方式，
           它既可以手动执行，也可以定期执行，其生成的RDB文件是一个经过压缩的二进制文件。
           
   + RDB文件的创建与载入
         
        + 创建
              
              SAVE命令直接阻塞服务器，创建RDB文件
              BGSAVE派生出一个子进程，创建RDB文件
        + 载入
             
              服务器启动时自动载入，服务器启动时会进入阻塞，直到载入完成为止
   
   + 自动间隔性保存
        
         // 服务器在900秒之内，对数据库进行了至少一次修改
         save 900 1                     
         // 服务器在300秒之内，对数据库进行了至少10次修改
         save 300 10
       
       
   + RDB文件结构
   
      + RDB文件结构
        
        | 名称 | 大小 | 说明|
        | :-----| :---- | :---- |
        | REDIS | 5bytes | 固定值,存放’R’,’E’,’D’,’I’,’S’|  
        | RDB_VERSION | 4bytes | RDB版本号|  
        | databases |  | 存储真正的数据|  
        | REDIS_RDB_OPCODE_EOF | 1byte | 255(0377),表述数据库结束| 
        | checksum |  | 	校验和|  
        
      + Databases结构  
      
         | 名称 | 大小 | 说明|
         | :-----| :---- | :---- |
         | RDB_OPCODE_SELECTDB | 1byte | 254,读到它时，接下来要读数据库的号|  
         | db_number | 1，2，5bytes | 存储数据库的号码，根据号码大小调大小|
         | key_value_pairs |  | 主要数据| 
         
      + key_value_pairs结构
      
         | 名称 | 大小 | 说明|
         | :-----| :---- | :---- |
         | RDB_OPCODE_EXPIRETIME_MS | 1byte | 252，说明是带过期时间的键值对| 
         | ms | 8bytes | 以毫秒为单位的时间戳|   
         | TYPE | 8bytes | 值对象的类型|
         | key |  | 键|
         | value |  | 值| 
         
         
   + 总结
      
       + RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据
       + SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器
       + BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器
       + 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件满足时，服务器会执行BASAVE命令
       + RDB是一个经过压缩的二进制文件
       + 对于不同类型的键值对，RDB会以不同方式保存它   
       
# AOF持久化
   + 简介
   
         AOF持久化通过保存Redis服务器所执行的写命令来记录数据库状态    
         
   + 实现
        
        + 命令追加
             ```
            struct redisServer{
                //..
                //AOF缓冲区
                sds aof_buf;
                //..
            } 
           ```        
          
        + AOF文件的写入与同步
            
              Redis服务器进程就是一个事件循环，这个循环的文件事件负责接收客户端的命令请求，
              以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。
             ```
                def eventLoop{
                    while true
                        #处理文件事件，接收命令请求以及发送回复
                        #处理命令请求时可能会有新的内容追加到aof_buf缓冲区
                        processFileEvents()
                    
                        # 处理事件事件
                        processTimeEvents()
                    
                        # 考虑是否要讲aof_buf中的内容写入和保存到AOF文件里面
                        flushAppendOnlyFile();
                }
             ```
          
             | appendfsync选项值 | flushAppendOnlyFile得行为 | 安全性|
             | :-----| :---- | :---- | 
             | always | 将aof_buf缓冲区的所有内容写入并同步到AOF文件 | 故障停机时，只丢失一个事件循环的命令数据|
             | everysec | 将aof_buf缓冲区的所有内容写入到AOF文件，如果上次同步aof文件的时间距离现在超过一秒钟，那么将再次同步 |丢失一秒钟的数据| 
             | no | 将aof_buf缓冲区的所有内容写入到AOF文件，何时同步由操作系统来决定 | 同步时间由操作系统决定，丢失的数据区间最长|
         
        + AOF数据载入与还原            
            
             + 创建一个伪客户端，用其执行AOF命令
             + 读取一条命令并执行
             + 重复2步骤，直到完成
             
        + AOF重写
            
             + 原因 ：AOF体积过大不利于数据还原，对服务器或宿主机造成影响；故可以通过一定的算法对命令进行压缩，例如对于同一个键的命令可以压缩。
              
             + 实现原理：无需读取AOF文件，而通过读取数据库当前状态，翻译为写入命令来重写AOF文件  
             + 后台重写：利用子进程重写，父进程可以继续处理命令请求；子进程带有服务器进程的数据副本，可以避免使用锁的情况下，保证数据安全；
             + 利用重写缓存区来解决数据不一致问题
             
             | 时间 | 父进程 | 子进程|
             | :-----| :---- | :---- |
             | T1 | 执行命令 SET K1 V1 | | 
             | T2 | 执行命令 SET K1 V2 | |   
             | T3 | 执行命令 SET K1 V3 | |
             | T4 | 创建子进程，开始AOF重写 | 开始AOF文件重写|
             | T5 | 执行命令 SET K2 10086| 执行重写操作| 
             | T6 | 执行命令 SET K3 12345 | 执行重写操作| 
             | T7 | 执行命令 SET K4 22222 | 完成重写操作，向父进程发送信号| 
             | T8 | 接收到子进程发来的信号，将命令SET K2 10086,SET K3 12345,SET K4 22222 追加到新的AOF文件末尾 | | 
             | T9 |  用新的AOF文件覆盖旧的AOF文件| | 
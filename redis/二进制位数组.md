# 二进制位数组
    Redis提供了SETBIT,GETBIT,BITCOUNT,BITOP四个命令用于处理二进制位数组
    
  + 位数组的表示
     
        Redis使用字符串对象来表示数组，因为字符串对象使用的SDS数据结构是二进制安全的，每个字节都是用一行来表示，逆序保存
        
  + GETBIT的实现
  
        GETBIT <bitarray><offset> 
       + 计算byte=[offset/8],byte值记录了offset偏移量指定的二进制保存在位数组的哪个字节
       + 计算byte=(offset mod 8)+1,bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位
       + 根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，并返回这个位的值
              
  + SETBIT的实现
  
        SETBIT <bitarray> <offset> <value>  
       + 计算len=[offset / 8] + 1，len记录了保存offset偏移量指定的二进制位至少需要多少字节；
       + 检查bitarray键保存的位数组长度是否小于len，如果是，扩展SDS长度为len字节，并将所有扩展的长度值置为0；
       + 计算byte = [offset / 8]，byte记录了offset偏移量指定的位保存在哪个字节；
       + 计算bit = (offset mod 8) + 1,bit记录了offset偏移量指定的二进制位是byte字节的第几个二进制位；
       + 根据byte值和bit值，在bitarray键保存的位数组中定位offset指定的二进制位，先记录指定二进制位保存的值到oldvalue，然后将新值设置为这个二进制位的值；
       + 向客户端返回oldvalue。   
       
  + BITCOUNT命令的实现
  
        BITCOUNT <bitarray>             
        
       二进制位统计算法：
        
       + 遍历算法：
        
        遍历每个二进制位，在遇到值为1的位时，计数器+1；
        效率太低，每次循环正检查一个二进制位的值是否为1，检查操作执行的次数与位数组包含的二进制位数量成正比。
       + 查表算法：
        
        对于一个有限集合来说，集合元素的排列方式是有限的；
        对于一个有限长度的位数组来说，它能表示的二进制位排列也是有限的。
        创建一个数字对应位为1个数的表，通过一次读取一个（或多个，需要建更大的映射表）字节，对比数字，就可以知道这个字节有几个位为1。键为数字，值为位上1的个数，查表。
        查表法的实际效果会受到内存和缓存两方面因素的限制：因为查表法是典型的空间换时间策略，节约的时间越多，花费的内存越大。
        查表法的效果会受到CPU缓存的限制：对于固定大小的CPU缓存，创建的表越大，CPU缓存所能保存的内容相比整个表越少，那么查表时出现缓存不命中的情况就会越多，缓存换入和换出操作就会越频繁，最终影响查表法的效率。
        
        
  + variable-precision SWAR算法
  
        BITCOUNT命令要解决的问题：统计一个位数组中非0二进制位的数量，在数学上被称为“计算韩明重量”。汉明重量经常被用于信息论，编码理论和密码学，所以研究人员开发了多种不同的算法，一些处理器甚至直接带有计算汉明重量的指令，对于不具备这种特殊指令的处理器来说，variable-precision SWAR算法是效率最好的，该算法通过一系列位移和位运算，可以在常数时间内计算多个字节的汉明重量，并且不需要额外的内存。
  
     以下是一个处理32位长度位数组的算法实现：
       ```
        uint32_t swar(uint32_t i){
         //步骤1
         i = (i & 0x55555555) + ((i >> 1) & 0x55555555);
         //步骤2
         i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
         //步骤3
         i = (i & 0x0f0f0f0f) + ((i >> 4) & 0x0f0f0f0f);
         //步骤4
         it = (i * (0x01010101) >> 24);
         return i
        }
       ```      
     执行步骤:
     
        1、计算出值i的二进制标志可以按每两个二进制位为一组进行分组，各组的十进制表示就是改组的汉明重量；
        2、计算出的值i的二进制表示可以按每四个二进制位为一组进行分组，各组的十进制表示就是改组的汉明重量；
        3、计算出的值i的二进制表示可以按每八个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。
        4、i*0x01010101计算出bitarray的汉明重量并记录在二进制位的最高八位，而>>24通过右移运算，将bitarray的汉明重量移动到最低八位，得出的结果就是汉明重量。
     
     因为swar函数是单纯的计算操作，所以它无需像查表法那样，使用额外的内存。而且swar函数是一个常数复杂度的操作，所以我们可以按照自己的需要，在一次循环中多次执行swar，从而按倍数提升计算汉明重量的效率。
     我们可以按照自己的需要，再一次循环中多次执行swar，从而按倍数提升计算汉明重量的效率：例如，我们在一次循环中调用两次swar函数，那么计算汉明重量的效率就从之前的一次循环计算32位提升到了一次循环计算64位。如果在一次循环中调用四次swar函数，那么一次循环级就可以计算128个二进制的汉明重量，这笔每次循环只调用一次swar函数块4倍。
     当然，一次循环执行多个swar调用这种优化方式是有极限的：一旦循环中处理数组的大小超过了缓存大小，这种优化的效果就会降低并最终消失。
     
     
  + Redis实现
  
    BITCOUNT命令的实现用到了查表和variable-precisionSWAR两种算法：
  
    查表算法使用键长为8位的表，表中记录了从0000 0000 到1111 1111在内的所有二进制位的汉明重量。
    variable-precisionSWAR算法，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision算法来计算这128个二进制位的汉明重量。
    程序会根据未处理的二进制位的数量来决定使用哪种算法：
    如果未处理的二进制位数量小于128位，那么程序使用查表法来计算二进制位的汉明重量。否则使用variable-precisionSWAR算法来计算二进制位的汉明重量。
  
  + BITTOP
    
    因为C语言直接支持对字节执行逻辑与，或，异或，非的操作，所以BITOP的四个操作都是直接基于这些逻辑操作来实现的。
    
    执行过程：
    + 创建一个空白的位数组value，用于保存逻辑操作的结果；
    + 对两个位数组的每个字节执行逻辑操作，并将结果保存到value[i]字节；
    + 经过前面的逻辑操作，程序得到了计算结果，并将它保存在result上。
     ```
    BITTOP AND <result > <operand-1>  [operand-2]
    
    BITTOP OR <result > <operand-1>  [operand-2]
    
    BITTOP NOT <result > <operand-1>  [operand-2]
    
    BITTOP XOR <result > <operand-1>  [operand-2]   
    ```
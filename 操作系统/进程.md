# 概念

  进程本质是一段可执行的程序。与每个进程相关的是地址空间，这是从某个最小值的存储位置到某个最大值存储位置的列表。
  在这个地址空间内，进程可以读写。该地址空间中存放有可执行程序，程序的数据以及程序的堆栈。对每个进程相关的还有资源集，
  通常包括寄存器（程序计数器和堆栈指针），打开文件的清单，突出的报警，有关进程清单以及运行该程序的所需要的的所有的其他信息。
  进程本质上是一个运行一个程序所需要所有信息的容器。
  
# 进程模型
  计算机上所有可运行的软件，通常也包括操作系统，被组织成若干个顺序进程。
  一个进程就是一个正在被执行的程序实例，包括程序计数器，寄存器和变量的当前值。
  从概念上说，每个进程拥有自己的虚拟CPU。当然实际上真正的CPU运行在进程之间来回切换。

# 进程创建

  4种主要事件会导致进程的创建：
  + 系统初始化
  + 正在运行的程序执行了创建进程的系统调用
  + 用户请求创建一个新进程
  + 一个批处理作业的初始化

  在unix系统中，只有一个系统调用可以创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。
  在调用fork之后，这两个进程拥有拥有相同单位内存映射，同样的环境字符串和同样的打开文件；

  进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。
  在unix中，子进程的初始地址空间时父进程的一个副本，但是这里涉及两个不同的地址空间，不可写的内存区是共享的。
  某些Unix实现使程序正文在两者间共享，因为它不能被修改。或者子进程共享父进程的所有内存，但这种情况下内存通过**写时复制**共享

# 进程的终止
  + 正常退出
  + 出错退出
  + 严重错误
  + 被其他进程杀死

# 进程的层次结构
  在unix中进程和它的子进程以及后裔组成一个进程组，树桩结构

# 进程的状态
  
    cat chapter1 chapter2 chapter3 | grep tree
   
  第一个进程运行cat，第二个运行grep；根据这两个进程的运行速度，可能发生grep已经准备就绪，但输入还没完成，于是阻塞grep，等待输入的到来
  
  进程的三种状态
   ![](https://outman-1252077993.cos.ap-nanjing.myqcloud.com/b7003af33a87e950f9264f8319385343fbf2b428.png)
  + 运行态（占用CPU）
  + 就绪态（可运行，但因为其他进程正在运行而暂时停止）
  + 阻塞态（触发某种外部事件发生，否则不能运行）

# 进程的实现
  为了实现进程模型，操作系统维护了一张进程表，每个进程占用一个进程表项，该表项包含了进程状态的关键信息。
  ![](https://outman-1252077993.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210403034253.png)
  
  一个程序在执行过程中可能被中断无数次，但它始终能返回中断前的状态
  中断向量与每一个I/O类关联，它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程3正在执行，则中断硬件程序将程序计数器，
  程序状态字，或寄存器压入堆栈，计算器随即跳转到中断服务例程接管接下来的一切剩余工作。

  **中断发生后操作系统最底层的工作步骤**
  + 硬件压入堆栈程序计数器等
  + 硬件从中断向量装入新的程序计数器
  + 汇编语言过程保存寄存器值
  + 汇编语言过程设置新的堆栈
  + C中断服务例程运行(典型的读和缓冲输入)
  + 调度程序决定下个将运行的进程
  + C过程返回至汇编代码
  + 汇编语言过程开始运行新的当前进程
  
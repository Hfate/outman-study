# 概述
    一个进程可以运行多个线程，线程可以理解为轻量级进程。
    同一个进程内的线程共享同一个地址空间，线程具有程序计数器，寄存器，堆栈，状态等内容。
    线程和进程一样也拥有阻塞，运行，就绪，终止等状态。

## POSIX线程
     
   线程调用 | 描述 |
   | :-----| :---- |
   | pthread_create| 创建一个新线程 |
   | pthread_exit| 结束调用的线程 |
   | pthread_join| 等待一个特定线程的退出 |
   | pthread_yield| 释放CPU来运行另外一个线程 |
   | pthread_attr_init| 创建并初始化一个线程的属性结构 |
   | pthread_attr_destroy| 删除一个线程的属性结构 |

## 在用户空间实现线程
   在用户空间管理线程时，每个进程有一个专用的线程表。他记录了各个线程的属性，例如程序计数器，堆栈指针，寄存器，状态等
   + 优点
      + 内核对线程一无所知，用户线程包可以在不支持线程的操作系统上实现。
      + 保存线程状态和调用程序都是本地过程，无需陷入内核，不需要上下文切换，也不需要对内存进行刷新
      + 允许每个进程有自定义的调度算法。例如某些应用程序中，那些有垃圾回收线程的应用程序就不用担心线程会在不合适的时候停止。
      + 具有更好扩展性，因需要一些固定表格空间和堆栈空间，如果使用内核实现的话，占用较大时会出现问题
   
   + 缺点
      + 需要实现阻塞调用，但又要避免影响其他线程
      + 在缺页中断时，内核由于不知道线程的存在，会把整个进程阻塞直至完成，尽管进程内其他线程可运行
   
## 在内核中实现线程
   在内核中创建线程表，用以保存线程信息
   + 优点
      + 阻塞线程的调用都是以系统调用的方式实现
      + 内核线程不需要新的，非阻塞系统调用
   
## 混合实现
   + 将用户线程与内核线程多路复用
   
## 调度激活机制
   目标： 模拟内核线程的功能（阻塞），又为其提供在用户空间才能实现的更好性能和更大灵活度

   实现方式：   **上行调用**

    通常n层提供n+1层可调用的服务，但是n层不能调用n+1中的过程，上行调用并不遵循这个原则
   内核给每个进程安排一个一定数量虚拟处理器，一旦如此激活，内核向进程发送通知事件，来激活运行时系统的调度。


   